- explain how 6502 does pipeliing. [ref](http://users.telenet.be/kim1-6502/6502/proman.html)

1. DIRECT ADDRESSING
    
2. 
    INDEXED ADDRESSIN
     Absolute indexed address is absolute addressing with an index
     register added to the absolute address. 
     Zero-Paged Indexed address is zero-paged addressing with an index
     register added to the absolute address. 
3.  INDIRECT ADDRESSING
          In solving a certain class of problems, it is sometimes necessary
     to have an address which is a truly computed value, not just a base
     address with some type of offset, but a value which is calculated or
     sometimes obtained as a group of addresses.  In order to implement
     this type of indexing or addressing, the use of indirect addressing
     has been introduced.

#### __Why do we have Indexed Addressing?__  
As has been developed in many of the previous examples, an index register has primary values as a modifier and as a counter.  As a modifier to a base address operation, it allows the accessing of contiguous groups of data by simple modification of the index.


### On arithmetic

#### Addition
There are 2 ways to do binary arithmetic addition. The first is unsigned. The second is signed. 
Doing unsigned addition is simple, you simply update the carry flag as needed. The role of the carry flag is clear here. Your computation exceded the 8-bit boundary into the 9th bit (which will certainly be 1 in such a case). Overflow tagis useless here.

In the case of signed addition, the `carry` flag is useless. You are working wih two 7-bit numbers, not 8, as the 8th bits are for the signs. The `overflow` flag comes in handy here. Any carry generated by the operation is found in the 8th bit. It is now upon the developer to interpret it that way. The overflow flag is also needed to interpret the results os signed arithmetic correctly. You use the same `adc`,`sbc` and co. in both cases. The difference is how you interpret he bits and flags.

The point of the overflow flag is this:
Case 1: When the 8th bit of the two operands are set, and the 8th bit of the result is unset, there is an overflow
Case 2: Also, when the 8th bit of the two operands are unset, but the 8th bit of the result is set, there is an overflow.

Case 1 tells us that two negative numbers operated on gave a +ve number as result. Surely there was an overflow.
Case 2 tells us that two positive numbers operated upon gave a -ve number result. Surely there must have been an overflow.

Again, it is important to know `adc` (and `sbc`) will always set both these flags (i.e. carry and overflow) in every case. The difference is in how the programmer interprets the flags, either by reading them or clearing them. That is the difference between signed and unsigned arithmetic. Its a matter of interpretation. The processor knows no difference between the two. It is also important to note that the processor sets (or unsets) the `zero` and `negative` flags in every arithmetic operation, including `inx`, `iny`, `dex`, `dey`, `inc`, `dec`.

#### Subtraction
Subtaction is done by deducting the value of the memory-fetched value and the carry from the accumulator. It uses twos compliment arithmetic. Rsult is stored in the accumulator. If a borrow occurs as a result of the subtraction, i.e. the result is >= 0, the `carry` flag is set, else it is reset. The carry flag being set means no borrow occured. 
`sbc` therefore means `A = A - M - !C`
Since `C` being unset signifies a borrow. 